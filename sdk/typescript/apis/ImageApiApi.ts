/* tslint:disable */
/* eslint-disable */
/**
 * ImageApi
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';

export interface AddWatermarkRequest {
    file: Blob;
    text: string;
    fontSize: number;
    opacity: number;
    margin: number;
    fmt: string;
}

export interface ApplyFilterRequest {
    file: Blob;
    type: string;
    fmt: string;
    intensity?: number;
}

export interface ConvertFormatRequest {
    file: Blob;
    fmt: string;
}

export interface CropImageRequest {
    file: Blob;
    x: number;
    y: number;
    width: number;
    height: number;
    fmt: string;
}

export interface CropRoundedRequest {
    file: Blob;
    x: number;
    y: number;
    width: number;
    height: number;
    radius: number;
    fmt: string;
}

export interface ResizeImageRequest {
    file: Blob;
    width: number;
    height: number;
    fmt: string;
}

/**
 * 
 */
export class ImageApiApi extends runtime.BaseAPI {

    /**
     */
    async addWatermarkRaw(requestParameters: AddWatermarkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling addWatermark().'
            );
        }

        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling addWatermark().'
            );
        }

        if (requestParameters['fontSize'] == null) {
            throw new runtime.RequiredError(
                'fontSize',
                'Required parameter "fontSize" was null or undefined when calling addWatermark().'
            );
        }

        if (requestParameters['opacity'] == null) {
            throw new runtime.RequiredError(
                'opacity',
                'Required parameter "opacity" was null or undefined when calling addWatermark().'
            );
        }

        if (requestParameters['margin'] == null) {
            throw new runtime.RequiredError(
                'margin',
                'Required parameter "margin" was null or undefined when calling addWatermark().'
            );
        }

        if (requestParameters['fmt'] == null) {
            throw new runtime.RequiredError(
                'fmt',
                'Required parameter "fmt" was null or undefined when calling addWatermark().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['text'] != null) {
            formParams.append('text', requestParameters['text'] as any);
        }

        if (requestParameters['fontSize'] != null) {
            formParams.append('fontSize', requestParameters['fontSize'] as any);
        }

        if (requestParameters['opacity'] != null) {
            formParams.append('opacity', requestParameters['opacity'] as any);
        }

        if (requestParameters['margin'] != null) {
            formParams.append('margin', requestParameters['margin'] as any);
        }

        if (requestParameters['fmt'] != null) {
            formParams.append('fmt', requestParameters['fmt'] as any);
        }

        const response = await this.request({
            path: `/watermark`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async addWatermark(requestParameters: AddWatermarkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.addWatermarkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async applyFilterRaw(requestParameters: ApplyFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling applyFilter().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling applyFilter().'
            );
        }

        if (requestParameters['fmt'] == null) {
            throw new runtime.RequiredError(
                'fmt',
                'Required parameter "fmt" was null or undefined when calling applyFilter().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['type'] != null) {
            formParams.append('type', requestParameters['type'] as any);
        }

        if (requestParameters['intensity'] != null) {
            formParams.append('intensity', requestParameters['intensity'] as any);
        }

        if (requestParameters['fmt'] != null) {
            formParams.append('fmt', requestParameters['fmt'] as any);
        }

        const response = await this.request({
            path: `/filter`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async applyFilter(requestParameters: ApplyFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.applyFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async convertFormatRaw(requestParameters: ConvertFormatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling convertFormat().'
            );
        }

        if (requestParameters['fmt'] == null) {
            throw new runtime.RequiredError(
                'fmt',
                'Required parameter "fmt" was null or undefined when calling convertFormat().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['fmt'] != null) {
            formParams.append('fmt', requestParameters['fmt'] as any);
        }

        const response = await this.request({
            path: `/convert`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async convertFormat(requestParameters: ConvertFormatRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.convertFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async cropImageRaw(requestParameters: CropImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling cropImage().'
            );
        }

        if (requestParameters['x'] == null) {
            throw new runtime.RequiredError(
                'x',
                'Required parameter "x" was null or undefined when calling cropImage().'
            );
        }

        if (requestParameters['y'] == null) {
            throw new runtime.RequiredError(
                'y',
                'Required parameter "y" was null or undefined when calling cropImage().'
            );
        }

        if (requestParameters['width'] == null) {
            throw new runtime.RequiredError(
                'width',
                'Required parameter "width" was null or undefined when calling cropImage().'
            );
        }

        if (requestParameters['height'] == null) {
            throw new runtime.RequiredError(
                'height',
                'Required parameter "height" was null or undefined when calling cropImage().'
            );
        }

        if (requestParameters['fmt'] == null) {
            throw new runtime.RequiredError(
                'fmt',
                'Required parameter "fmt" was null or undefined when calling cropImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['x'] != null) {
            formParams.append('x', requestParameters['x'] as any);
        }

        if (requestParameters['y'] != null) {
            formParams.append('y', requestParameters['y'] as any);
        }

        if (requestParameters['width'] != null) {
            formParams.append('width', requestParameters['width'] as any);
        }

        if (requestParameters['height'] != null) {
            formParams.append('height', requestParameters['height'] as any);
        }

        if (requestParameters['fmt'] != null) {
            formParams.append('fmt', requestParameters['fmt'] as any);
        }

        const response = await this.request({
            path: `/crop`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async cropImage(requestParameters: CropImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.cropImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async cropRoundedRaw(requestParameters: CropRoundedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling cropRounded().'
            );
        }

        if (requestParameters['x'] == null) {
            throw new runtime.RequiredError(
                'x',
                'Required parameter "x" was null or undefined when calling cropRounded().'
            );
        }

        if (requestParameters['y'] == null) {
            throw new runtime.RequiredError(
                'y',
                'Required parameter "y" was null or undefined when calling cropRounded().'
            );
        }

        if (requestParameters['width'] == null) {
            throw new runtime.RequiredError(
                'width',
                'Required parameter "width" was null or undefined when calling cropRounded().'
            );
        }

        if (requestParameters['height'] == null) {
            throw new runtime.RequiredError(
                'height',
                'Required parameter "height" was null or undefined when calling cropRounded().'
            );
        }

        if (requestParameters['radius'] == null) {
            throw new runtime.RequiredError(
                'radius',
                'Required parameter "radius" was null or undefined when calling cropRounded().'
            );
        }

        if (requestParameters['fmt'] == null) {
            throw new runtime.RequiredError(
                'fmt',
                'Required parameter "fmt" was null or undefined when calling cropRounded().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['x'] != null) {
            formParams.append('x', requestParameters['x'] as any);
        }

        if (requestParameters['y'] != null) {
            formParams.append('y', requestParameters['y'] as any);
        }

        if (requestParameters['width'] != null) {
            formParams.append('width', requestParameters['width'] as any);
        }

        if (requestParameters['height'] != null) {
            formParams.append('height', requestParameters['height'] as any);
        }

        if (requestParameters['radius'] != null) {
            formParams.append('radius', requestParameters['radius'] as any);
        }

        if (requestParameters['fmt'] != null) {
            formParams.append('fmt', requestParameters['fmt'] as any);
        }

        const response = await this.request({
            path: `/crop/rounded`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async cropRounded(requestParameters: CropRoundedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.cropRoundedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async resizeImageRaw(requestParameters: ResizeImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling resizeImage().'
            );
        }

        if (requestParameters['width'] == null) {
            throw new runtime.RequiredError(
                'width',
                'Required parameter "width" was null or undefined when calling resizeImage().'
            );
        }

        if (requestParameters['height'] == null) {
            throw new runtime.RequiredError(
                'height',
                'Required parameter "height" was null or undefined when calling resizeImage().'
            );
        }

        if (requestParameters['fmt'] == null) {
            throw new runtime.RequiredError(
                'fmt',
                'Required parameter "fmt" was null or undefined when calling resizeImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['width'] != null) {
            formParams.append('width', requestParameters['width'] as any);
        }

        if (requestParameters['height'] != null) {
            formParams.append('height', requestParameters['height'] as any);
        }

        if (requestParameters['fmt'] != null) {
            formParams.append('fmt', requestParameters['fmt'] as any);
        }

        const response = await this.request({
            path: `/resize`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async resizeImage(requestParameters: ResizeImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resizeImageRaw(requestParameters, initOverrides);
    }

}
